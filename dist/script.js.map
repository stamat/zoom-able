{
  "version": 3,
  "sources": ["../node_modules/book-of-spells/src/browser.mjs", "../src/scripts/script.js"],
  "sourcesContent": ["/** @module browser */\n\nimport { isEmpty, isFunction } from './helpers.mjs'\nimport { css } from './dom.mjs'\nimport { parseUrlParameters } from './parsers.mjs'\n\nexport function isUserAgentIOS(str) {\n  return /iPad|iPhone|iPod/i.test(str)\n}\n\nexport function isUserAgentMobile(str) {\n  return /\\b(BlackBerry|webOS|iPhone|IEMobile)\\b/i.test(str) ||\n    /\\b(Android|Windows Phone|iPad|iPod)\\b/i.test(str)\n}\n\nexport function isUserAgentSafari(str) {\n  return /^((?!chrome|android|crios|fxios).)*safari/i.test(str)\n}\n\n/**\n * Check if the device is an iOS device\n * \n * @returns boolean True if the device is an iOS device, false otherwise\n */\nexport function isIOS() {\n  return isUserAgentIOS(navigator.userAgent) && 'maxTouchPoints' in navigator && navigator.maxTouchPoints > 1\n}\n\n/**\n * Check if the device is a mobile device\n * \n * @returns boolean True if the device is a mobile device, false otherwise\n */\nexport function isMobile() {\n  if ('maxTouchPoints' in navigator) return navigator.maxTouchPoints > 0\n\n  if ('matchMedia' in window) return !!matchMedia('(pointer:coarse)').matches\n\n  if ('orientation' in window) return true\n\n  return isUserAgentMobile(navigator.userAgent)\n}\n\n/**\n * Check if the browser is Safari\n *\n * @returns boolean True if the browser is Safari, false otherwise\n */\nexport function isSafari() {\n  if (navigator.hasOwnProperty('vendor')) /apple/i.test(navigator.vendor)\n  return isUserAgentSafari(navigator.userAgent)\n}\n\n/**\n * Check if the browser is Safari on iOS\n * \n * @returns boolean True if the browser is Safari on iOS, false otherwise\n */\nexport function isIOSSafari() {\n  return isIOS() && isSafari()\n}\n\n/**\n * A wrapper for the matchMedia function, cause with `matchMedia` you can only either add a listener or check the media query\n * this function does both.\n * \n * @param {string} query The media query to check\n * @param {function} [callback] The callback function to call when the media query changes\n * @returns {boolean} The result of the media query\n * \n * @example\n * mediaMatcher('(min-width: 768px)', (matches) => {\n *  if (matches) {\n *    // Do something\n *  } else {\n *    // Do something else\n *  }\n * })\n * \n * // Or\n * \n * const isDesktop = mediaMatcher('(min-width: 768px)')\n */\nexport function mediaMatcher(query, callback) {\n  if (isFunction(callback)) {\n    matchMedia(query).addEventListener('change', (e) => {\n      callback(e.matches)\n    })\n\n    const mql = matchMedia(query)\n    callback(mql.matches)\n\n    return mql.matches\n  }\n\n  return matchMedia(query).matches\n}\n\n/**\n * Get the scrollbar width\n * \n * When preventing scroll with html overflow hidden the scroll bar will disappear and the whole page will shift (if the scroll bar is visible that is).\n * To substitute for the scrollbar width we can add a padding to the body element.\n * \n * @returns {number} The scrollbar width\n * \n * @example\n * const scrollbarWidth = getScrollbarWidth() // 15 (on MacOS X Safari)\n */\nexport function getScrollbarWidth() {\n  const scrollDiv = document.createElement('div')\n  \n  css(scrollDiv, {\n    width: '100px',\n    height: '100px',\n    position: 'absolute',\n    left: '-9999px',\n    zIndex: '0',\n    overflowX: 'hidden',\n    overflowY: 'scroll'\n  })\n\n  document.body.appendChild(scrollDiv)\n  const scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth\n  document.body.removeChild(scrollDiv)\n  return scrollbarWidth\n}\n\n/**\n * Check if the vertical scrollbar is visible\n * \n * @param {number} [scrollbarWidth] The width of the scrollbar, defaults to getScrollbarWidth()\n * @returns {boolean} True if the vertical scrollbar is visible, false otherwise\n */\nexport function hasVerticalScrollbarVisible(scrollbarWidth) {\n  if (scrollbarWidth === undefined) scrollbarWidth = getScrollbarWidth()\n  return window.innerHeight < document.body.scrollHeight && scrollbarWidth > 0\n}\n\n/**\n * Check if the horizontal scrollbar is visible\n * \n * @param {number} [scrollbarWidth] The width of the scrollbar, defaults to getScrollbarWidth()\n * @returns {boolean} True if the horizontal scrollbar is visible, false otherwise\n */\nexport function hasHorizontalScrollbarVisible(scrollbarWidth) {\n  if (scrollbarWidth === undefined) scrollbarWidth = getScrollbarWidth()\n  return window.innerWidth < document.body.scrollWidth && scrollbarWidth > 0\n}\n\n/**\n * Disable the scroll on the page.\n * \n * @param {number} [shift=0] If greater than 0 the body will be shifted to the left by the width of the scrollbar, getScrollbarWidth() is used to provide this value  \n */\nexport function disableScroll(shift) {\n  const body = document.body\n  if (shift && hasVerticalScrollbarVisible(shift)) body.style.paddingRight = `${shift}px`\n  body.style.overflow = 'hidden'\n}\n\n/**\n * Enable the scroll on the page.\n * \n * @param {boolean} [shift=0] If greater than 0 the body will be shifted back to the left by the width of the scrollbar, getScrollbarWidth() is used to provide this value\n */\nexport function enableScroll(shift) {\n  const body = document.body\n  body.style.overflow = ''\n  if (shift) body.style.paddingRight = ''\n}\n\n/**\n * Parses a string of url query parameters into an object of key value pairs. Converts the values to the correct type.\n * \n * @param {string} [entryQuery] - Optional query string to parse, without the starting ?, defaults to window.location.search without the starting ?\n * @returns {object} of key value pairs\n * @example\n * // url: https://example.com/?test&foo=bar&baz=qux\n * getQueryProperties() // { test: undefined, foo: 'bar', baz: 'qux' }\n */\nexport function getQueryProperties(entryQuery) {\n  const query = entryQuery ? entryQuery : window.location.search.replace('?', '')\n  if (isEmpty(query)) return {}\n\n  return parseUrlParameters(query)\n}\n\n/**\n * Parses a string of url hash parameters into an object of key value pairs. Converts the values to the correct type.\n * \n * @param {string} [entryHash] - Optional hash string to parse, without the starting #, defaults to window.location.hash without the starting #\n * @returns {object} of key value pairs\n * @example\n * // url: https://example.com/#test&foo=bar&baz=qux\n * getHashProperties() // { test: undefined, foo: 'bar', baz: 'qux' }\n */\nexport function getHashProperties(entryHash) {\n  const hash = entryHash ? entryHash : window.location.hash.replace('#', '')\n  if (isEmpty(hash)) return {}\n\n  return parseUrlParameters(hash)\n}\n\nfunction onHashChange(callback) {\n  const hash = window.location.hash.replace('#', '')\n  if (!isEmpty(hash)) callback(hash)\n}\n\n/**\n * Add a callback function to the hash change event\n * \n * @param {function} callback - The callback function to call when the hash changes\n * @param {string} [single] - Optional string to make sure the listener is initialized only once, defaults to window[single] which is set to true after the first call\n * @example\n * hashChange((hash) => {\n * // Do something with the hash\n * })\n */\nexport function hashChange(callback, single) {\n  onHashChange(callback)\n  \n  if (single && window[single]) return\n  if (single) window[single] = true\n  \n  window.addEventListener('hashchange', () => {\n    onHashChange(callback)\n  })\n}\n", "import { isMobile } from 'book-of-spells'\n\nconsole.log(`hello ${isMobile() ? 'mobile' : 'desktop'} world!`)\n"],
  "mappings": ";;;AAUO,WAAS,kBAAkB,KAAK;AACrC,WAAO,0CAA0C,KAAK,GAAG,KACvD,yCAAyC,KAAK,GAAG;AAAA,EACrD;AAoBO,WAAS,WAAW;AACzB,QAAI,oBAAoB;AAAW,aAAO,UAAU,iBAAiB;AAErE,QAAI,gBAAgB;AAAQ,aAAO,CAAC,CAAC,WAAW,kBAAkB,EAAE;AAEpE,QAAI,iBAAiB;AAAQ,aAAO;AAEpC,WAAO,kBAAkB,UAAU,SAAS;AAAA,EAC9C;;;ACvCA,UAAQ,IAAI,SAAS,SAAS,IAAI,WAAW,SAAS,SAAS;",
  "names": []
}
